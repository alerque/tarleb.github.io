[
  {
    "objectID": "posts/extending-pandoc-with-lua/index.html",
    "href": "posts/extending-pandoc-with-lua/index.html",
    "title": "Extending pandoc with Lua",
    "section": "",
    "text": "My first exposure to Lua has been as a pandoc user, and adding new Lua features to pandoc turned Lua into one of my favorite languages. In this post I will take a look at pandoc, the universal document converter, and explore how one can script and extend it with Lua. Pandoc includes a Lua interpreter since 2012, but the integration of Lua has been expanded significantly with the latest 2.0 release. My hope for this article is to highlight the beauty of these systems."
  },
  {
    "objectID": "posts/extending-pandoc-with-lua/index.html#the-universal-document-converter",
    "href": "posts/extending-pandoc-with-lua/index.html#the-universal-document-converter",
    "title": "Extending pandoc with Lua",
    "section": "The universal document converter",
    "text": "The universal document converter\nPandoc – written and maintained by John MacFarlane – is an relatively old project. It has grown considerably since the first version was published in 2006: at the time of writing, pandoc can read 27 different document formats and dialects, and can write 49 formats. Besides serving as a one-off document conversions tool, pandoc also frequently features as the central part of publishing pipelines. For example, Pandoc is used in static site generators and is frequently used by academic writers, due also to its excellent support for citations.\nAs a brief example, consider the following commands which transform Markdown input into docx, HTML, or PDF:\n# command to convert a markdown file to docx\npandoc input-file.md --output=output-file.docx\n\n# convert to HTML\npandoc input-file.md --standalone --output=output-file.html\n\n# convert to PDF (via LaTeX)\npandoc input-file.md --output=output-file.pdf\nMany conversion tasks need to alter the default behavior or require special conversion features. This highlights the importance of good customization support for a conversion tool, one of the areas in which Lua shines.\nPandoc is unusual for a Lua-extendable program, in that it is written in Haskell. Using Haskell is very productive, but is less suitable as an extension language: its concepts are often alien to users of other languages, and shipping a full Haskell interpreter with pandoc would result in considerable bloat. Lua is an excellent choice here, as it is lightweight, simple, and beautiful. It should be noted, however, that bridging Haskell and Lua is its own can of worms and worth a separate blog post."
  },
  {
    "objectID": "posts/extending-pandoc-with-lua/index.html#pandocs-document-ast",
    "href": "posts/extending-pandoc-with-lua/index.html#pandocs-document-ast",
    "title": "Extending pandoc with Lua",
    "section": "Pandoc’s document AST",
    "text": "Pandoc’s document AST\nAn important factor in pandoc’s immense transformation powers is its use of a unifying document representation: Every input is parsed into this document AST, which is then rendered in the desired output format. While a direct conversion between any of n input and m output formats would require n  m* converters, using an intermediate representation reduces complexity to n + m.\nThere are additional advantages to this: as we’ll see, it becomes much simpler to work with a unified document representation than it would be to work with any of the input or output formats directly.\nThere are four main types in pandoc’s document model: inlines, blocks, document metadata, and the full document.\n\nInline elements represent text and text markup. Examples are Space for inter-word spaces, Str for (usually non-whitespace) text, and Emph for emphasized text.\nBlocks are elements like paragraphs, lists, code listings, and headers. They are usually rendered in lines or blocks of their own; many block elements contain lists of inline elements.\nMeta information is a simple mapping from string keys to meta values. Meta values can be thought of as a special JSON or YAML object.\nLast but not least, the Pandoc type represents a full document. A Pandoc element consists of a lists of block elements, plus additional document metadata.\n\nPandoc’s Lua features revolve around modifying or converting these elements. The oldest use of Lua in pandoc enables the conversion of AST elements into strings as to output any document format."
  },
  {
    "objectID": "posts/extending-pandoc-with-lua/index.html#custom-writers",
    "href": "posts/extending-pandoc-with-lua/index.html#custom-writers",
    "title": "Extending pandoc with Lua",
    "section": "Custom writers",
    "text": "Custom writers\nUsers can define custom writers in Lua to render any document format. Each of the aforementioned AST elements is transformed to a string by calling a Lua function of the same name as the element. E.g., this example demonstrates how emphasized text can be rendered as HTML:\nfunction Emph(content_string)\n  return '<em>' .. content_string .. '</em>'\nend\nA full custom writer is defined by specifying functions for all document AST elements. Example writers using this method include 2bbcode by @lilydjwg (依 云), as well as pandoc’s sample.lua. The latter is a well documented starting point for authors of new custom writers. The file can be produced by calling pandoc --print-default-data-file=sample.lua.\nThe pandoc-scholar project serves as an example for the power offered by custom writers. It is a publishing tool intended to help authors of scholarly articles and was created with custom Lua writers. The tool leans on the custom writers feature in ways that writers were not intended to be used, which resulted in the development of lua filters."
  },
  {
    "objectID": "posts/extending-pandoc-with-lua/index.html#filters",
    "href": "posts/extending-pandoc-with-lua/index.html#filters",
    "title": "Extending pandoc with Lua",
    "section": "Filters",
    "text": "Filters\nAn additional benefit of a unified document type is that the document can be modified programmatically, regardless of which input and output format is chosen. Pandoc provides two interfaces for this.\n\nJSON Filters\nThe first – very flexible – method is based on JSON. Pandoc can serialize the document to JSON; other programs can read and modify the document. The resulting document JSON is passed back to pandoc, thus allowing users to use any programming language capable of parsing JSON to alter the document. Many libraries for various languages have been implemented, including Haskell, Python, Ruby, and JavaScript.\nThe flexibility of JSON filters can also be a disadvantage, as it requires additional software and usually the full installation of a scripting language’s ecosystem. Pandoc is designed to work on all major platforms and without any dependencies on other libraries and binaries. Depending on additional software can be problematic, especially for non-technical users.\n\n\nLua filters\nThe Lua filter system added in pandoc 2.0 not only solves the portability issue of JSON filters, but also offers better performance and more functionality. Document elements can be selectively serialized to Lua tables, modified using the full power of Lua, and will then be transferred back, thus replacing the previous values.\nLua filters operate by calling filter functions on each element of the specified name. I.e., if a Lua filter contains a function with the same name as an AST element, then this function is called for all elements of the respective type. The serialized element is passed as input to the filter function, and the function’s return value is deserialized and used to replace the input element. This method is as simple as it is flexible, and fits well with the concept of immutability which is prevalent in Haskell programs: pandoc ignores modifications to the serialized object itself, it will just use the filter function’s return value.\nThe following example filter transforms all text set in small caps into emphasized text:\nfunction SmallCaps (element)\n  return pandoc.Emph(element.content)\nend\nThe element constructor functions in module pandoc, like pandoc.Emph in the above example, are also the central step when transforming elements from their pandoc-internal representation to Lua values. This ensures consistency in the way element values are produced, whether during serialization or through a constructor call in the filter script. The current implementation uses only strings, tables, and some metatables when constructing element values, with the goal of marking these values easy and flexible to use."
  },
  {
    "objectID": "posts/extending-pandoc-with-lua/index.html#lua-filter-example-macro-expander",
    "href": "posts/extending-pandoc-with-lua/index.html#lua-filter-example-macro-expander",
    "title": "Extending pandoc with Lua",
    "section": "Lua filter example: macro expander",
    "text": "Lua filter example: macro expander\nBelow is the code for a simple macro expander using pandoc’s Lua filter functionality. The expander replaces all macro occurrences in the given document. Macro definitions are hard-coded into the filter, but could as well be read from an external file.\n-- file: macro-expander.lua\n\n-- Macro substitutions: contains macro identifier as\n-- keys and the expanded inlines as values.\nlocal macro_substs = {\n  ['{{hello}}'] = pandoc.Emph{pandoc.Str \"Hello, World!\"}\n}\n\n-- Replace string with macro expansion, if any.\nfunction Str (s)\n  return macro_substs[s.text] or s\nend\nThe heart of the macro expander is the function Str. It is called on all simple strings in the document. The return value of this function is then read back into pandoc, replacing the original Str value.\nAssume a Markdown file greeting.md:\nGreeting: {{hello}}\nWe can apply the macro expander by calling\npandoc --lua-filter macro-expander.lua greeting.md\nresulting in the expected expansion:\n\n\nGreeting: Hello, World!\n\n\nThe function Str could be shortened further by dropping the trailing or s:\nfunction Str (s) return macro_substs[s.text] end\nThis is a convenience feature of pandoc filters: if the function returns no value (or nil), the original value is kept unchanged. This makes filter functions easier to write and speeds up filtering, as unchanged elements don’t need to be deserialized again."
  },
  {
    "objectID": "posts/extending-pandoc-with-lua/index.html#whats-good-and-whats-next",
    "href": "posts/extending-pandoc-with-lua/index.html#whats-good-and-whats-next",
    "title": "Extending pandoc with Lua",
    "section": "What’s good, and what’s next",
    "text": "What’s good, and what’s next\nUsing pandoc with Lua is a fast, flexible, and platform independent way of augmenting pandoc with additional functionality. For me personally, having the full power of Lua at ones finger tips proved to be a lot of fun, while opening unexpected document processing possibilities.\nPandoc and its Lua subsystem are under constant development. E.g., the next versions will feature more utility functions exposed via Lua modules. There is constant work to make more and more internal functions available. The next big goal is to grant scripting access to all format-output functions. However, this requires some changes to pandoc’s internals. It remains a long way for pandoc to become a fully Lua-scriptable publishing platform.\nIf you want to learn more about Lua filters, the Lua filter docs is a good place to start. It includes up-to-date examples of Lua scripts, as well as a reference of all modules and functions accessible via Lua. Pandoc’s user manual is a good resource to learn about all of pandoc features and its command line options.\nFeedback is always welcome!"
  },
  {
    "objectID": "posts/extending-pandoc-with-lua/index.html#acknowledgements",
    "href": "posts/extending-pandoc-with-lua/index.html#acknowledgements",
    "title": "Extending pandoc with Lua",
    "section": "Acknowledgements",
    "text": "Acknowledgements\nA big thank you to Jennifer König, Birgit Pohl, and John MacFarlane for their feedback on an earlier version of this post, and to all pandoc contributors and users, who make working on this project incredibly fun."
  },
  {
    "objectID": "posts/pdf-of-the-lua-manual/index.html",
    "href": "posts/pdf-of-the-lua-manual/index.html",
    "title": "PDF Version of the Lua Manual",
    "section": "",
    "text": "A question came up on the Lua mailing list, asking whether there was a PDF version of the Lua manual. This is, of course, the home domain of pandoc, and I got nerd-sniped into producing a PDF (and ePUB) version of the manual.\nThis is a good opportunity to showcase some pandoc features. The post describes the process of going from an HTML web page to a PDF file via LaTeX and pandoc. We will see how to"
  },
  {
    "objectID": "posts/pdf-of-the-lua-manual/index.html#invoking-pandoc",
    "href": "posts/pdf-of-the-lua-manual/index.html#invoking-pandoc",
    "title": "PDF Version of the Lua Manual",
    "section": "Invoking pandoc",
    "text": "Invoking pandoc\nThe first step is to call pandoc on the Lua manual website. Even when keeping everything bare-bones, the result is already decent:\npandoc --pdf-engine=xelatex --output=lua-manual.pdf \\\n    \"https://lua.org/manual/5.4/manual.html\"\nProduces\n\n\n\nFirst page of unoptimized PDF\n\n\nThis requires a somewhat recent version of pandoc as well as XeLaTeX to be installed. It is possible to forgo the trouble of installing the requirements by using the pandoc/latex Docker image:\ndocker run --rm -v \"$PWD\":/data -u $(id -u):$(id -g) pandoc/latex:2.9.2.1 \\\n    --pdf-engine=xelatex --output=lua-manual.pdf \\\n    \"https://lua.org/manual/5.4/manual.html\""
  },
  {
    "objectID": "posts/pdf-of-the-lua-manual/index.html#replacing-characters",
    "href": "posts/pdf-of-the-lua-manual/index.html#replacing-characters",
    "title": "PDF Version of the Lua Manual",
    "section": "Replacing characters",
    "text": "Replacing characters\nThe above commands will produce warnings about characters which are unavailable in the default fonts. We don’t want characters to go missing, of course, so let’s fix that first. The warnings are:\n[WARNING] Missing character: There is no ≤ (U+2264) in font [lmmono10-regular]:!\n[WARNING] Missing character: There is no ≤ (U+2264) in font [lmmono10-regular]:!\n[WARNING] Missing character: There is no π (U+03C0) in font [lmroman10-italic]:mapping=tex-text;!\nSearching the page for ≤ shows that it is used in inline code, while π occurs as emphasized character in the description of math.pi. We could, of course, search for a font which has the appropriate glyphs and instruct pandoc/LaTeX to use it. But we’ll go a different route.\nA good way to improve the result of a converstion is to use a pandoc Lua filter. We create a file called beautify-manual.lua and pass it to pandoc via the --lua-filter=beautify-manual.lua command line option.\nHandling ≤ is straight forward, we just replace the char with the slightly uglier looking ASCII sequence <= in all code elements.\nfunction Code (c)\n  c.text = c.text:gsub('≤', '<=')\n  return c\nend\nWhile there is no italics version π in the default font, there is such a glyph in the default math font. Pandoc’s internal representation for π is Emph [Str \"π\"], which we replace with a math element holding the same content.\nfunction Emph (e)\n  local s = e.content[1]\n  if #e.content == 1 and s.tag == 'Str' and s.text == 'π' then\n    return pandoc.Math('InlineMath', 'π')\n  end\nend\nThe document now compiles without warnings, and all characters are properly included."
  },
  {
    "objectID": "posts/pdf-of-the-lua-manual/index.html#add-table-of-contents",
    "href": "posts/pdf-of-the-lua-manual/index.html#add-table-of-contents",
    "title": "PDF Version of the Lua Manual",
    "section": "Add Table of Contents",
    "text": "Add Table of Contents\nThe Lua manual is long, often used as a reference, and, in its HTML version, comes with a table of contents on a separate page. The PDF, for it to be useful as a reference, should have a table of contents as well. Pandoc can be told to generate a table of contents by adding the --toc command line flag. The toc depth is controlled via --toc-depth; 2 is a good setting here. However, in this case, the result is neither pleasing nor informative:\n\n\n\nBad looking table of contents\n\n\nSomething is terribly wrong. By inspecting the parsed document by running pandoc --to=native …, we see that all Headers contain a Span. That span holds the actual contents. Apparently LaTeX does not like this and omits the content of the span when generating the toc.\nThe span also has the id used by links to the header. Numbered sections start with the section number, which we’d rather produce via pandoc.\nfunction Header (h)\n  -- Unnumbered sections have the main contents as the first element.\n  -- Numbered sections start with the number and an em-dash, so\n  -- the Span is the fifth element (Lua multipass).\n  local span\n  if h.content[1].tag == 'Str' and h.content[1].text:match '[%d%.]+' then\n    span = h.content[5]\n  else\n    span = h.content[1]\n    h.classes:insert('unnumbered')\n  end\n\n  h.identifier = span.identifier\n  h.content = span.content\n\n  return h\nend\nThe filter also removes the section numbering. We add it back by passing --number-sections to pandoc.\n\n\n\nless-bad table of contents\n\n\nNot bad."
  },
  {
    "objectID": "posts/pdf-of-the-lua-manual/index.html#improve-title-and-metadata",
    "href": "posts/pdf-of-the-lua-manual/index.html#improve-title-and-metadata",
    "title": "PDF Version of the Lua Manual",
    "section": "Improve title and metadata",
    "text": "Improve title and metadata\nThe PDF is already quite usable, let’s prettify it a bit more: It would be important to properly list the authors in the title and metadata, remove the unnecessary first header, and maybe add the Lua logo to the title. All this is easiest when acting on the full document.\nfunction Pandoc (doc)\n  -- comma separated authors\n  local authors = doc.blocks[2]\n  authors.content:remove(1)  -- remove 'by'\n  doc.meta.author = pandoc.List()\n  for author in pandoc.utils.stringify(authors):gmatch '[^,]+' do\n    doc.meta.author:insert(author)\n  end\n\n  -- Remove unnecessary blocks\n  doc.blocks:remove(4) -- menubar\n  doc.blocks:remove(2) -- authors paragraph\n  doc.blocks:remove(1) -- title header\n\n  -- add subtitle image\n  doc.meta.subtitle = pandoc.MetaInlines{\n    pandoc.RawInline('latex', '\\\\vspace{1em}'),\n    pandoc.Image(\"Lua logo\", -- \"https://www.lua.org/images/lua-logo.gif\")\n  }\n  return doc\nend"
  },
  {
    "objectID": "posts/pdf-of-the-lua-manual/index.html#final-touch",
    "href": "posts/pdf-of-the-lua-manual/index.html#final-touch",
    "title": "PDF Version of the Lua Manual",
    "section": "Final touch",
    "text": "Final touch\nFinally, we may want the PDF to add a little more visible structure, e.g., starting top-level sections on their own page.\nThe command used by pandoc to create the top level headings can be controlled with the --top-level-division option. Setting that option to chapter ensures that each major section starts on a new page. However, the default document class used by LaTeX doesn’t allow chapters, so a different class has to be set with --variable documentclass=report."
  },
  {
    "objectID": "posts/pdf-of-the-lua-manual/index.html#summary",
    "href": "posts/pdf-of-the-lua-manual/index.html#summary",
    "title": "PDF Version of the Lua Manual",
    "section": "Summary",
    "text": "Summary\nFor completeness, here is the full pandoc command used to generate the PDF:\npandoc \\\n  --toc \\\n  --toc-depth=2 \\\n  --metadata=documentclass=report \\\n  --pdf-engine=xelatex \\\n  --lua-filter=lua-manual-cleanup.lua \\\n  --number-sections \\\n  --top-level-division=chapter \\\n  --output=lua-5.4-manual.pdf \\\n  \"https://lua.org/manual/5.4/manual.html\"\nOne of the big advantages of pandoc is that it offers a lot of freedom. Since we already cleaned the content up, we can now also create other formats, like an ebook, just by changing the name of the output file. The final results are available below:\n\nLua 5.4 manual (PDF)\nLua 5.4 manual (EPUB)"
  },
  {
    "objectID": "posts/santas-little-lua-scripts/index.html",
    "href": "posts/santas-little-lua-scripts/index.html",
    "title": "Santa’s Little Lua Scripts",
    "section": "",
    "text": "Santa sighted deeply as worry and uncertainty gave way, leaving a feeling of relieve and accomplishment. The year was one of the worst he’d seen so far. Large numbers of his helpers were moving from the North Pole to Antarctica to satisfy their ambient temperature preferences. There would be many telecommuting Elves this year, and each helper enjoyed additional autonomy. Tying everything together was a challenge. But he had succeeded: the wishes processing program was finished, and the elves would be able to help Santa from the comfort of their new homes."
  },
  {
    "objectID": "posts/santas-little-lua-scripts/index.html#wishes",
    "href": "posts/santas-little-lua-scripts/index.html#wishes",
    "title": "Santa’s Little Lua Scripts",
    "section": "Wishes",
    "text": "Wishes\nThe part of the wishes system that Santa had been working on was focused on classic toys: wooden bricks, dolls, and train sets.\ndata Toy = Bricks | TrainSet | Doll deriving Show\nThe system also kept track of basic data about the children:\ndata Behavior = Nice | Naughty deriving (Eq, Show)\n\ndata Child = Child\n  { childName     :: Text\n  , childBehavior :: Behavior\n  } deriving (Show)\nChildren and toys were tied together in a wish.\ndata Wish = Wish\n  { wishingChild :: Child\n  , wishedToy    :: Toy\n  } deriving (Show)\nIt was most elegant. The problem for Santa was that the Elves, being independent and autonomous workers, needed to access and process the data in very custom ways. Unfortunately for him, very few Elves had a Haskell build environment installed, so he had to distribute the binary. Writing a completely custom processing language seemed like an enormous rabbit hole."
  },
  {
    "objectID": "posts/santas-little-lua-scripts/index.html#lua",
    "href": "posts/santas-little-lua-scripts/index.html#lua",
    "title": "Santa’s Little Lua Scripts",
    "section": "Lua",
    "text": "Lua\nFortunately, Santa had a better idea: Lua, an embeddable scripting language. He had been using it for some projects1 and also made use of it in pandoc, which he used to answer his mails. Santa would just need to expose the relevant parts of the Haskell system, so the Elves could access and script it as their hearts desired. He looked for a library, found HsLua, and got to work."
  },
  {
    "objectID": "posts/santas-little-lua-scripts/index.html#exposing-data",
    "href": "posts/santas-little-lua-scripts/index.html#exposing-data",
    "title": "Santa’s Little Lua Scripts",
    "section": "Exposing data",
    "text": "Exposing data\nLua has a simple, yet powerful, stack-based API. The first step towards exposing Haskell data was to push them to the Lua stack. Keeping things simple, Santa chose strings to represent toys:\npushToy :: Toy -> Lua ()\npushToy = pushString . show\nLua offers only a single construct to structure data: tables. So that’s what Child and Wish were represented with.\npushChild :: Child -> Lua ()\npushChild (Child name behavior) = do\n  -- create new Lua table on the stack\n  newtable\n  -- push string to stack\n  pushText name\n  -- table now in position 2; assign string to field in table\n  setfield (nth 2) \"name\"\n\n  -- push boolean to stack\n  pushBool (behavior == Nice)\n  setfield (nth 2) \"nice\"\n\npushWish :: Wish -> Lua ()\npushWish (Wish child toy) = do\n  newtable\n  pushChild child\n  setfield (nth 2) \"child\"\n  pushToy toy\n  setfield (nth 2) \"toy\""
  },
  {
    "objectID": "posts/santas-little-lua-scripts/index.html#running-scripts",
    "href": "posts/santas-little-lua-scripts/index.html#running-scripts",
    "title": "Santa’s Little Lua Scripts",
    "section": "Running scripts",
    "text": "Running scripts\nSanta’s goal for now was to allow his Elves to filter the list of wishes so each finds the ones relevant to them. For example, if an Elf only cares about wishes for train sets from children who were nice, then they should be able to use a script to filter those wishes out.\nreturn function (wish)\n  return wish.child.nice and\n    wish.toy == 'TrainSet'\nend\nThe script returns a (lambda) function that serves as a predicate for wishes. The function can be thought of having the type Wish -> IO Bool. Santa needed to turn the Lua lambda function into an actual Haskell function runPredicate :: Wish -> Lua Bool. If Santa assumed that the lambda function was at the top of the Lua stack, then he could push a Wish value to the Lua stack, call the function, and retrieve the result value from the stack.\nrunPredicate :: Wish -> Lua Bool\nrunPredicate wish = do\n  -- Assume filter function is at the top of the stack;\n  -- create a copy so we can re-use it.\n  pushvalue top\n  pushWish wish\n  -- Call the function. There is one argument on the stack,\n  -- and we expect one result to be returned.\n  call (NumArgs 1) (NumResults 1)\n  toboolean top <* pop 1\nWhat remained was loading the Elves’ script files. Santa did this with dofile of type FilePath -> Lua Status. The predicate then ends up on the top of the Lua stack, and can be called through runPredicate, e.g. to select a subset of wishes via filterM.\nmain :: IO ()\nmain = do\n  filterFile <- fmap (!! 0) getArgs -- get first argument\n  result <- run $ do\n    _status <- dofile filterFile\n    filterM runPredicate wishes\n  print result\nSanta tested his creation on a short list of wishes\nwishes :: [Wish]\nwishes =\n  [ Wish (Child \"Theodor\" Nice) Bricks\n  , Wish (Child \"Philine\" Nice) TrainSet\n  , Wish (Child \"Steve\" Naughty) Doll\n  ]\nby running runhaskell wish-filter predicate.lua. To his uttermost satisfaction, the terminal echoed the right information back to him.\n[Wish {wishingChild = Child {childName = \"Philine\", childBehavior = Nice}, wishedToy = TrainSet}]\nHe reclined in his chair, shut down his device, and enjoyed a double chocolate chip cookie of which he felt very deserving now.\n\nSanta’s full code, as presented here, is available as part of the examples at https://github.com/hslua/hslua."
  },
  {
    "objectID": "posts/rt6_redirect/index.html",
    "href": "posts/rt6_redirect/index.html",
    "title": "rt6_redirect: source isn’t a valid nexthop for redirect target",
    "section": "",
    "text": "The zeitkraut server is configured to work with IPv6. For quite some time now, I’ve been seeing some strange errors in my log files. If you’ve been noticing something similar, here is what’s going on and how to prevent the messages from appearing."
  },
  {
    "objectID": "posts/rt6_redirect/index.html#the-problem",
    "href": "posts/rt6_redirect/index.html#the-problem",
    "title": "rt6_redirect: source isn’t a valid nexthop for redirect target",
    "section": "The Problem",
    "text": "The Problem\nEverything works as expected, except for some weird messages in the logs:\nrt6_redirect: source isn't a valid nexthop for redirect target\nNot even startpage was of much help. Searching for the above line only lists only some unanswered forum questions and the kernel source code which is producing the message. Oh, and a somewhat unhelpful blog entry telling people to always use their routers link local address when routing. This is useless advice in my case, I don’t have a link-local address of the router, only it’s global address."
  },
  {
    "objectID": "posts/rt6_redirect/index.html#the-cause",
    "href": "posts/rt6_redirect/index.html#the-cause",
    "title": "rt6_redirect: source isn’t a valid nexthop for redirect target",
    "section": "The Cause",
    "text": "The Cause\nI found a way to stop the message from appearing in my logs. On the way, I learned a bit more about IPv6 and improved server security on the way.\nIPv6 contains functionality to tell a computer about better routes to the target destination. A router may send ICMPv6 redirect packages (type 137 to be specific), informing neighboring computers about more effective ways to reach their targets. This makes the most sense when applied within an environment heavily relying on auto-configuration – like a dynamic internal company or home network. It makes a lot less sense for servers very stable network topologies.\nAttackers may try to exploit the redirect functionality by including themselves into the route to the target. The specification for those redirects includes some security-measures, requiring the attacker to correctly guess the server’s current next hop. If the attackers get it wrong, the Linux kernel refuses to use the new routing information. This is most-likely what happens when you see the above log messages."
  },
  {
    "objectID": "posts/rt6_redirect/index.html#the-solution",
    "href": "posts/rt6_redirect/index.html#the-solution",
    "title": "rt6_redirect: source isn’t a valid nexthop for redirect target",
    "section": "The Solution",
    "text": "The Solution\nLong talk short, the solution is to disable IPv6 redirecting:\nsudo sysctl net.ipv6.conf.all.accept_redirects=0\nMy server is not a router, so there is no need to accept any kind of route changing messages from external sources. We can simply disable redirects, using above command. The change can be made permanent by setting the value in /etc/sysctl.conf. In fact, we can disable routing for both IPv4 and IPv6. Be careful though, you might happen to be in a network environment requiring you to accept redirect commands for some reason.\nIf you are on Debian or similar distribution like Ubuntu, change the following lines in /etc/sysctl.conf from\n# Do not accept ICMP redirects (prevent MITM attacks)\n#net.ipv4.conf.all.accept_redirects = 0\n#net.ipv6.conf.all.accept_redirects = 0\n# _or_\n# Accept ICMP redirects only for gateways listed in our default\n# gateway list (enabled by default)\n# net.ipv4.conf.all.secure_redirects = 1\n#\n# Do not send ICMP redirects (we are not a router)\n#net.ipv4.conf.all.send_redirects = 0\n#\n# Do not accept IP source route packets (we are not a router)\n#net.ipv4.conf.all.accept_source_route = 0\n#net.ipv6.conf.all.accept_source_route = 0\nto\n# Do not accept ICMP redirects (prevent MITM attacks)\nnet.ipv4.conf.all.accept_redirects = 0\nnet.ipv6.conf.all.accept_redirects = 0\n#\n# Do not send ICMP redirects (we are not a router)\nnet.ipv4.conf.all.send_redirects = 0\n#\n# Do not accept IP source route packets (we are not a router)\nnet.ipv4.conf.all.accept_source_route = 0\nnet.ipv6.conf.all.accept_source_route = 0\nRunning sudo sysctl -p loads the new settings."
  },
  {
    "objectID": "posts/rt6_redirect/index.html#alternative-solution",
    "href": "posts/rt6_redirect/index.html#alternative-solution",
    "title": "rt6_redirect: source isn’t a valid nexthop for redirect target",
    "section": "Alternative Solution",
    "text": "Alternative Solution\nCompletely disabling redirects in the kernel should keep you reasonably secure. However, if you need redirects within your internal network, you could also block redirect packages reaching you through external interfaces. E.g., to block redirect packages coming in on eth1, one would issue\nsudo ip6tables -A -i eth1 -p icmpv6 --icmpv6-type 137 -j DROP\nHowever, firewall configuration is a complex topic, so I’m not going to go into details here.\nIf you have any questions, corrections or comments on the matter, please drop me a line."
  },
  {
    "objectID": "posts/howto-zsh-vi-style/index.html",
    "href": "posts/howto-zsh-vi-style/index.html",
    "title": "How to configure zsh with vi bindings and nice shortcuts",
    "section": "",
    "text": "Having a good working environment is vital for feeling comfortable being productive. This extends to computational tools and the command shell is an integral part of the daily work for many of us. It’s a good idea to configure the shell’s interface to be efficient and pleasant to use. Here we see how zsh, arguably the best shell around, can be configured to suit the needs of people used to vi key bindings (which are arguably arguably superior and more ergonomical than the default emacs-style bindings)1."
  },
  {
    "objectID": "posts/howto-zsh-vi-style/index.html#using-vi-bindings-in-the-shell",
    "href": "posts/howto-zsh-vi-style/index.html#using-vi-bindings-in-the-shell",
    "title": "How to configure zsh with vi bindings and nice shortcuts",
    "section": "Using vi-bindings in the shell",
    "text": "Using vi-bindings in the shell\nThe first step towards nice vi key bindings is almost too easy: The red pill takes the form of\nbindkey -v\nType it into your prompt (and add it to your .zshrc file) and emacs bindings are going bye-bye. Escape will bring you to normal-mode, while i, a, o etc. will bring you back to insert-mode, just as with your favorite editor. Use j and k in normal-mode to go through your history and move around within the line with h, l, w, b and the like.\nThis is a good start, let’s see how we can bring it from “this is nice” to “that’s just awesome”.\nFirst, we may want to keep some of the default key bindings in insert-mode since we’ve grown accustomed to them. No missing out, let’s put them back in:\n# Kill input from the current point to the end of line with Ctrl-k\nbindkey '^k' kill-line\n# Search the history incremantally with Ctrl-r\nbindkey '^r' history-incremental-search-backward\n# Insert and go through the \"last words\" of previous commands with Meta-.\n# (or Escape-. for that matter).\nbindkey '^[.' insert-last-word\n# Show the man-page or other helpful infos with Meta-h\nbindkey '^[h' run-help\nYou can take a look at the key bindings defined for emacs-mode by typing bindkey -M emacs -L and reuse the bindings you like. See the zshzle manpage for more pre-defined widgets for which you could define bindings."
  },
  {
    "objectID": "posts/howto-zsh-vi-style/index.html#configuring-the-prompt-to-show-the-current-editing-mode",
    "href": "posts/howto-zsh-vi-style/index.html#configuring-the-prompt-to-show-the-current-editing-mode",
    "title": "How to configure zsh with vi bindings and nice shortcuts",
    "section": "Configuring the prompt to show the current editing mode",
    "text": "Configuring the prompt to show the current editing mode\nSo the key bindings are quite usable now, but it’s a bit unfortunate that it is impossible to see if the shell is in insert- or normal-mode. There should be a mode indicator right in the shell prompt!\n# You may already have those in your .zshrc somewhere\nautoload -U promptinit && promptinit\nautoload -U colors     && colors\n\nsetopt prompt_subst\n\n# Set the colors to your liking\nlocal vi_normal_marker=\"[%{$fg[green]%}%BN%b%{$reset_color%}]\"\nlocal vi_insert_marker=\"[%{$fg[cyan]%}%BI%b%{$reset_color%}]\"\nlocal vi_unknown_marker=\"[%{$fg[red]%}%BU%b%{$reset_color%}]\"\nlocal vi_mode=\"$vi_insert_marker\"\nvi_mode_indicator () {\n  case ${KEYMAP} in\n    (vicmd)      echo $vi_normal_marker ;;\n    (main|viins) echo $vi_insert_marker ;;\n    (*)          echo $vi_unknown_marker ;;\n  esac\n}\n\n# Reset mode-marker and prompt whenever the keymap changes\nfunction zle-line-init zle-keymap-select {\n  vi_mode=\"$(vi_mode_indicator)\"\n  zle reset-prompt\n}\nzle -N zle-line-init\nzle -N zle-keymap-select\n\n# Multiline-prompts don't quite work with reset-prompt; we work around this by\n# printing the first line(s) via a precmd which is executed before the prompt\n# is printed.  The following can be integrated into PROMPT for single-line\n# prompts.\n#\n# Colorize freely\nlocal user_host='%B%n%b@%m'\nlocal current_dir='%~'\nprecmd () print -rP \"${user_host} ${current_dir}\"\n\nlocal return_code=\"%(?..%{$fg[red]%}%? %{$reset_color%})\"\nPROMPT='${return_code}${vi_mode} %# '\nThis gives a prompt in the style of\nuser@host /current/working/path\n[I] %\nwhere [I] is the insert-mode indicator and is changed to [N] when normal-mode is activated. Neat, isn’t it?"
  },
  {
    "objectID": "posts/howto-zsh-vi-style/index.html#single--and-multi-key-shortcuts",
    "href": "posts/howto-zsh-vi-style/index.html#single--and-multi-key-shortcuts",
    "title": "How to configure zsh with vi bindings and nice shortcuts",
    "section": "Single- and multi-key shortcuts",
    "text": "Single- and multi-key shortcuts\nThis is all nice and dandy, but it’s not quite like vim yet. How about those sweet bindings where pressing jj in quick succession brings us to normal-mode without having to press Esc? Setting it up is easy as pie.\n# Time in which two keys have to be pressed in order to be recognized as a\n# single command (in centiseconds, set to 0.4 sec by default -- may be\n# modified as needed).\nexport KEYTIMEOUT=40\nbindkey 'jj' vi-cmd-mode\nWe can also add two-key bindings to jump to the start and end of the line:\n# Bind to both possible orders in which the keys could be pressed.\n# Move all the way to the left\nbindkey ';l' end-of-line\nbindkey 'l;' end-of-line\n# Move all the way to the right\nbindkey ';h' beginning-of-line\nbindkey 'h;' beginning-of-line\nJumping to the beginning of the line is now as easy as pressing ; and h at the same time. No need to switch to normal-mode and your fingers don’t leave the your keyboard’s home-row. Try it, it’s great!"
  },
  {
    "objectID": "posts/howto-zsh-vi-style/index.html#more",
    "href": "posts/howto-zsh-vi-style/index.html#more",
    "title": "How to configure zsh with vi bindings and nice shortcuts",
    "section": "More",
    "text": "More\nCustomizations like this can make it much more pleasant to use the command line and boost your productivity. If the above is still not enough, here are some more ideas:\n\nDefine custom keymaps, e.g. to control other programs such as mpc or tmux.\nSwitch to said keymaps via some nice bindings.\nShow the status of version control systems and build environments in the prompt.\n\nIf you don’t feel like doing all the work yourself, I can heartly reommend you take a look at oh-my-zsh. It offers a great collection of ideas to build on and some really cool ready-to-use plugins. Have fun!"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this Site\nThe page is build using Quarto. To learn more about Quarto websites visit https://quarto.org/docs/websites."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "tarleb’s site",
    "section": "",
    "text": "Santa’s Little Lua Scripts\n\n\n\n\n\n\n\nlua\n\n\nhslua\n\n\nexample\n\n\n\n\n\n\n\n\n\n\n\nDec 6, 2020\n\n\nAlbert Krewinkel\n\n\n\n\n\n\n  \n\n\n\n\nPDF Version of the Lua Manual\n\n\n\n\n\n\n\npandoc\n\n\nlua\n\n\npdf\n\n\n\n\nUsing pandoc and some filters to render the Lua manual as PDF.\n\n\n\n\n\n\nJul 11, 2020\n\n\nAlbert Krewinkel\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExtending pandoc with Lua\n\n\n\n\n\n\n\npandoc\n\n\nlua\n\n\npandoc-filter\n\n\n\n\n\n\n\n\n\n\n\nDec 23, 2017\n\n\nAlbert Krewinkel\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nrt6_redirect: source isn’t a valid nexthop for redirect target\n\n\n\n\n\n\n\nsecurity\n\n\nipv6\n\n\nserver\n\n\n\n\n\n\n\n\n\n\n\nAug 1, 2014\n\n\nAlbert Krewinkel\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHow to configure zsh with vi bindings and nice shortcuts\n\n\n\n\n\n\n\nzsh\n\n\nvi\n\n\nkey bindings\n\n\n\n\n\n\n\n\n\n\n\nJun 29, 2014\n\n\nAlbert Krewinkel\n\n\n\n\n\n\nNo matching items"
  }
]